---
title: Android源码设计模式解析与实战
tags: [android,设计模式]
date: 2016/12/1
categories: 技术类
---
# 面向对象的六大原则

稳定性 扩展性 健壮性 灵活性 高内聚 低耦合

## 1、单一职责原则

一个类应该是一组相关性很高的函数、数据的封装。

## 2、开闭原则

软件中的对象（类、模块、函数等）应该对扩展是开放的，对修改是封闭的。

## 3、里氏替换原则

抽象，多态（行为多态、对象多态）。

## 4、依赖倒置原则

高层和低层都应该依赖抽象，抽象接口之间进行依赖。

## 5、接口隔离原则

客户端不应该依赖所不需要的接口。

## 6、迪米特原则

减少类之间的依赖，降低耦合。

***
# 单例模式
**创建型模式**，确保某一个类只有一个实例，并可以自行实例化并像整个系统提供这个实例

## 场景

* 某个对象过多消耗资源
* 某种类型的对象应该只有一个

## 实现

1. 构造函数私有化
2. 通过静态函数或者枚举返回单例对象
3. 在多线程环境下，确保单例对象只有一个
4. 在反序列化时，确保不会重新创建对象

## 种类

1. 饿汉式（实例化类时就直接创建，消耗资源）
2. 懒汉式（每次获取单例时，都会synchronized同步，消耗不必要的资源）
3. 双重检查式（DCL，由于java自身问题，不适用于高并发情况）
4. 静态内部类式（推荐使用，实例化内部类时才会创建实例，线程安全、对象单一）
5. 枚举单例（线程安全、对象单一，无反序列化问题）
6. 容器式（使用map容器保存单例，如获取Android系统服务）

## 优点

* 减少内存开支，尤其是需要频繁创建销毁一个对象，性能又无法优化时
* 所创建的对象占资源比较大，可以只创建一个对象，永驻内存
* 避免同一资源的同时操作
* 优化全局资源的共享

## 缺点

* 没有接口，扩建较为困难
* 如果单例对象持有Context对象，容易发生内存泄漏，如果使用，最好使用ApplicationContext

***
# 建造者模式
**创建型模式**，将一个复杂的对象的构建与表示分离，使得同样的构建过程可以表示为不同的形式，允许用户不知道内部的构造细节，但可以更加精确的控制对象的构造流程

## 场景

* 多个部件或者零件都可以装配到一个对象中，但产生的结果不同时
* 初始化一个对象或者产品类特别复杂，如参数多，但有默认值时

## 实现

* Product产品类——产品的抽象类
* Builder——抽象的Builder，规范组建，常使用调用链实现（返回值为本对象，代码简介、易懂）
* ConcreteBuilder——具体的Builder类
* Director——统一组装过程

## 优点

* 良好的封装性，构建时不比知晓内部构建细节
* 良好的扩展性，建造者独立

## 缺点

* 产生多余的Builder和Dirctor对象，消耗内存

***
# 原型模式
**创建型模式**，复制原型实例，创建一个相同的对象，不会执行构造函数

## 场景

* 创建一个对象需要特别多的数据准备、访问权限，类初始化时消耗很多资源
* 保护性拷贝，避免自己的对象被修改

## 实现

### 实现

1. 继承Cloneable接口
2. 重写方法`clone()`
3. 修改`clone()`方法访问权限为protect或者public
4. `return super.clone()`等操作

### 浅拷贝（影子拷贝）

内部引用类型数据还是使用的相同地址，数据对象为同一个

### 深拷贝（推荐使用）

内部引用类型的数据也被clone，与原型数据不是同一个

## 优点

在内存中进行二进制流拷贝，性能好，速度快

## 缺点

构造函数不会执行，开发时应该注意

***
# 工厂模式
**创建型模式**，定义一个用于创建对象的接口，让子类决定实例化哪个类

## 场景

* 生成复杂对象

## 实现

### 实现

1. 抽象工厂——Factory
2. 具体工厂——ConcreteFactory
3. 抽象产品——Product
4. 具体产品——ConcreteProduct

### 多工厂模式

经常使用**反射**更简洁的生产某个对象

### 静态工厂模式

直接返回某个产品实例，工厂类比较多

## 优点

* 扩展性好
* 耦合低

## 缺点

* 新增加产品时，要引入抽象层，导致类结构复杂化

***
# 策略模式
**行为型模式**，封装一系列的算法，它们可以相互替换，分离算法，让算法独立于它的客户端而独立变化

## 场景

* 针对同种问题可用多种算法处理时
* 需要**安全的**封装多种同类型操作时
* 同一抽象有多个子类，需要用if-else/switch-case来具体选择子类时

## 实现

Android中的时间插值器TimeInterpolator

1. Context——用来操作策略的上下文环境，维护Strategy抽象的实例
2. Strategy——策略的抽象
3. ConcreteStrategyA、ConcreteStrategyB——具体的策略实现

## 优点

* 结构清晰明了，简单直观
* 耦合度相对较低，易扩展
* 封装彻底，数据安全

## 缺点

* 随着策略的增加，类的数量也会增加

***
# 状态模式
**行为型模式**，当一个对象内在的状态改变时，允许改变它的行为

## 注意

* 结构类似于策略模式，但是目的、本质不同。
* 状态模式的行为是平行的、不可替换的
* 策略模式的行为是彼此独立、可相互替换的
* 根据自身的情况将不同状态作为不同的独立对象，不同的状态对象之间不依赖其他对象，可独立变化

## 场景

* 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为，如Android中的Wi-Fi状态
* 代码中包含大量的状态判断语句，如if-else、switch-case。

## 实现

1. Context——环境类，维护一个State子类的实例，这个实例定义了对象的当前状态
2. State——抽象状态类或者状态接口，定义一个或一组接口，表示该状态下的行为
3. ConcreteStateA、ConcreteStateB——具体的状态类，实现State接口，不同状态有不同的行为

## 优点

* 结构清晰，扩展性和维护性高，符合单一职责原则

## 缺点

* 增加类和对象的个数

***
# 责任链模式
**行为型模式**，使多个对象都有机会处理同一个请求，将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理为止

## 场景

* 多个对象可以处理同一个请求，但具体由谁处理动态决定

## 实现

1. Handler——抽象处理角色，声明处理方法，并保持对下一个处理者的引用
2. ConcreteHandlerA、ConcreteHandlerB——具体处理角色，处理请求或者转发给下一个处理者
3. Request——抽象请求，声明被处理时的方法
4. ConcreteRequestA、ConcreteRequestB——具体请求，实现被处理时的方法

## 注意

* 纯的责任链：被某个对象处理
* 不纯的责任联：没有被对象处理（常用）
* 两个行为，一是处理请求，二是传递给下一个对象，不允许处理后传递给上一个对象

## 优点

* 将请求者和处理者解耦，提高代码灵活性

## 缺点

* 如果处理者过多，会影响性能，尤其是递归调用

***
# 观察者模式
**行为型模式**，一对多的依赖关系，当被观察者改变时，所有依赖它的观察者对象都会得到通知并会自动更新

## 场景

* 事件多级触发场景
* 消息交换场景，如消息队列，事件总线等
* Android中数据库观察更新

## 实现

1. Subject（Observable）——抽象主题，把所有观察者对象的引用保存在一个集合中，并提供接口，可以增删观察者对象
2. ContreteSubject（ContreteObservable）——具体主题，当状态改变时，通知观察者
3. Observer——抽象观察者，定义一个接口，当主题改变时通知时改变自己
4. ConreteObserver——具体观察者，实现抽象观察者的接口

## 优点

* 将观察者和被观察者抽象耦合，应对业务变化
* 增强系统的灵活性和扩展性

## 缺点

* 观察者如果过多，会影响性能
* 如果一个观察者中途卡顿，必定影响整体效率，这时候要考虑使用异步处理

***
# 代理模式（委托模式）
**结构型模式**，提供一种代理以控制对这个对象的访问

## 场景

* 无法或者不想直接访问这个对象时
* 访问某个对象比较困难时

## 注意

* 为了保证客户端使用的透明性，委托对象需要与被代理对象实现相同的接口

## 实现

### 静态代理

1. Subject——抽象主题类或者接口，声明真实主题与代理接口的共同方法
2. RealSubject——真实主题类，被委托类或者被代理类，操作实际的业务逻辑
3. ProxySubject——代理类，持有真实主题类的引用，实现的接口方法操作真实主题类实现的接口方法

### 动态代理(一脸懵逼中...)
java提供了动态代理接口InvocationHandler

```
	public class DynamicProxy implements InvocationHandler{
	
		private Object mRealSubject;
	
		public DynamicProxy(Object mRealSubject){
			this.mRealSubject = mRealSubject;
		}
	
		@Override
		public Object invoke(Object proxy, Method method, Object[] args){
			return method.invoke(mRealSubject, args);
		}
	}
``` 
``` 
	public static void main(String[] args){
		
		Subject realSubject = new RealSubject();
	
		DynamicProxy proxy = new DynamicProxy(realSubject);
	
		Subject subject = (Subject)Proxy.newProxyInstance(realSubject.getClass.getClassLoader(), new Class[]{ Subject.class }, proxy);
	
		subject.innerMethod();
	
	}
``` 

***
# 适配器模式
**结构型模式**，将两个不同接口的对象粘合起来协同工作

## 场景

* 接口不兼容或者彼此之间没有联系的类
* 需要统一的输出接口，但输入类型未知

## 实现

### 类适配器模式

容易暴露一些奇怪的接口，用户使用成本变高

1. Target——目标角色，也就是所期待的接口
2. Adaptee——现有类，自己的接口，需要去转换
3. Adapter——适配器角色，**继承自Adaptee**，实现Target接口，将Adaptee现有接口转换为期待接口

### 对象适配器模式

灵活，更加实用

1. Target——目标角色，也就是所期待的接口
2. Adaptee——现有类，自己的接口，需要去转换
3. Adapter——适配器角色，**拥有Adaptee实例**，实现Target接口，将Adaptee现有接口转换为期待接口

## 优点

* 更好的复用性
* 更好的扩展性

## 缺点

* 过多的使用适配器，会让系统显得凌乱，不易整体把握

***
# 装饰模式（包装模式）
**结构型模式**，动态的给一个对象增加额外的功能，相比与继承更加灵活，是继承关系的一种替代方案，如`onCreate()`方法

## 实现

1. Component——抽象组件，一个接口或者抽象类，充当被装饰的原始对象
2. ConcreteComponent——组件具体实现类，实现Component接口，也就是被实际装饰的对象
3. Decorator——抽象装饰者，继承自Component，保持一个Component的引用
4. ConcreteDecoratorA、ConcreteDecoratorB——装饰者的具体实现类，对抽象装饰者做出具体的实现

## 注意

装饰模式和代理模式相似，容易混淆

1. 装饰模式是扩展对象功能，是对继承的一种替代方案
2. 代理模式是对拥有的对象进行控制，不会增强功能

***
# MVC

## 介绍

* MVC是一种框架模式，不是设计模式，但可以看作**观察者模式、策略模式、组合模式**的合体，核心在观察者模式。
* 框架面向于相同行为代码的重用
* 设计面向于相同结构代码的重用
* 架构介于框架和设计模式之间
* 框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度

*三种级别的重用*

1. 内部重用：在同一应用中能公共使用的抽象块
2. 代码重用：将通用模块组合成库或者工具集，以便在多个应用和领域都能使用
3. 框架重用：为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性

Android中的MVC

1. View——XML文件
2. Controller——Activity
3. Model——数据处理

## 作用

* 控制器Activity主要作用就是解耦，将视图View和模式Model进行分离，两者在Activity中进行绑定或者完成其他的逻辑

***
# MVP

## 介绍

* MVP模式可以分离显示层和逻辑层，它们之间通过接口通信，依赖接口，降低耦合

Android中的MVP

1. Presenter——交互中间人

	Presenter主要作为沟通View和Model的桥梁，他从Model层检索数据之后，返回给View层，使View和Model之间没有耦合，也将业务逻辑从View上抽离出来。

2. View——用户界面

	View通常指Activity、Fragment或者某个View控件，它含有一个Presenter成员变量。通常View需要实现一个IView逻辑接口，将View上的操作通过会转交给Presenter进行实现，最后Presenter调用IView逻辑接口将结果返回给View元素。

3. Model——业务模型

	Model角色的主要功能是提供数据的存取。Model是封装了数据库DAO或者网络获取数据的角色。

## 与MVC区别

### MVC特点

1. 用户可以向View发送指令，再由View直接调用Model改变状态
2. 用户也可以向Controller发送指令，再由Conroller调用View或者Model改变状态
3. Controller起到事件路由的作用，同时部分业务逻辑也部署在Controller中

### 区别

* MVC的耦合性还是相对较高的，View可以直接与Model交互，导致M、V、C直接构成回路
* MVP中的View和Model不能直接通信，需要经过Presenter间接发出请求通信

## MVP的生命周期

### 问题

* 内存泄漏

	假设请求网络数据，Presenter拥有Activity的强引用，如果在请求结束之前Activity被销毁了，网络请求还没有返回，导致Presenter一直持有Activity对象，使得Activity对象无法被回收，此时发生了内存泄漏


### 解决方案

* 在Activity的生命周期中添加Presenter创建、销毁的方法
* 建立一个BaseActivity和BasePresenter，在BaseActivity的生命周期中添加BasePresenter的生命周期方法
* Presenter中最好对View的引用为软引用，如果Activity没有走生命周期方法直接销毁了，也不会造成内存泄漏，但可能出问题。

## 优点

* 良好的扩展性、可测试性、稳定性、可维护性、整洁性、灵活性
* 职责单一、抽象、最小化、低耦合


















